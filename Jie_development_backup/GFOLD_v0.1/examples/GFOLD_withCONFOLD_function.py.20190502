#!usr/bin/env python
# python GFOLD.py  --target T0967  --fasta T0967.fasta --alignment T0967.pir  --atomdir ./  --dir  T0967
# python GFOLD.py  --target 3BFO-B  --fasta 3BFO-B.fasta --alignment 3BFO-B.pir  --atomdir ./  --dir  3BFOB


############################################################################
#
#	 GFOLD : A Distance-based Protein Structure Folding
#
#	 Copyright (C) 2019 -2029	Jie Hou and Jianlin Cheng
#
############################################################################
#
#	 Method to perform distance-based modeling (TS)
#
############################################################################

from __future__ import print_function
import optparse
import numpy as np
import sys
import os
import collections
import IMP
import IMP.atom
import IMP.container
import IMP.rotamer
import warnings
import string, re
warnings.filterwarnings("ignore")
#/home/jh7x3/fusion_hybrid/
project_root = '/data/jh7x3/GFOLD_v0.1/'
sys.path.insert(0, project_root)

#from GFOLD_pylib import *
aa_one2index = {'A':0, 'C':1, 'D':2, 'E':3, 'F':4, 'G':5, 'H':6, 'I':7, 'K':8, 'L':9, 'M':10, 'N':11, 'P':12, 'Q':13, 'R':14, 'S':15, 'T':16, 'V':17, 'W':18, 'Y':19}
aa_three2index = {'ALA':0, 'CYS':1, 'ASP':2, 'GLU':3, 'PHE':4, 'GLY':5, 'HIS':6, 'ILE':7, 'LYS':8, 'LEU':9, 'MET':10, 'ASN':11, 'PRO':12, 'GLN':13, 'ARG':14, 'SER':15, 'THR':16, 'VAL':17, 'TRP':18, 'TYR':19}
aa_index2three = {y:x for x,y in aa_three2index.iteritems()}

print('')
print('  ############################################################################')
print('  #                                                                          #')
print('  #      GFOLD : A Distance-based Protein Structure Folding                  #')
print('  #                                                                          #')
print('  #   Copyright (C) 2019 -2029	Jie Hou and Jianlin Cheng                   #')
print('  #                                                                          #')
print('  ############################################################################')
print('  #                                                                          #')
print('  #   Method to perform distance-based modeling (TS)                         #')
print('  #                                                                          #')
print('  ############################################################################')
print('')


parser = optparse.OptionParser()
parser.add_option('--target', dest='target',
	default = 'test',    # default target name is test
	help = 'name of target protein')
parser.add_option('--fasta', dest = 'fasta',
	default = '',    # default empty!
	help = 'FASTA file containing the protein to sequence to fold')
parser.add_option('--ss', dest = 'ss',
	default = '',    # default empty!
	help = 'Secondary structure file containing the protein to sequence to 3-class secondary structure')
parser.add_option('--alignment', dest = 'alignment',
	default = '',    # default empty!
	help = 'alignement file for the target <pir format>')
parser.add_option('--atomdir', dest = 'atomdir',
	default = '',    # default empty!
	help = 'PDB structure for template protein in the pir alignment')
parser.add_option('--restraints', dest = 'restraints',
	default = '',    # default empty!
	help = 'restraints for modeling')
parser.add_option( '--dir', dest = 'dir',
	default = '',    # default empty!
	help = 'root directory for results')
parser.add_option( '--lambda', dest = 'lamda',
	default = '0.4',    # default empty!
	help = 'root directory for results')

(options,args) = parser.parse_args()


file_pair = ''
target = options.target
# Sequence file option
sequence = ''
if options.fasta:	
	f = open(options.fasta, 'r')	
	sequence = f.readlines()	
	f.close()	
	# removing the trailing "\n" and any header lines
	sequence = [line.strip() for line in sequence if not '>' in line]
	sequence = ''.join( sequence )
else:
	print('Error ! target protein not defined. Exiting application...')
	sys.exit(1)

residues = {}
for i in range(0, len(sequence)):
	char = sequence[i:i+1]
	residues[i+1] = char
# SS sequence file option
ss_sequence = ''

if options.ss:	
	f = open(options.ss, 'r')	
	ss_sequence = f.readlines()	
	f.close()	
	# removing the trailing "\n" and any header lines
	ss_sequence = [line.strip() for line in ss_sequence if not '>' in line]
	ss_sequence = ''.join( ss_sequence )
else:
	print('Error ! secondary structure not defined. Exiting application...')
	sys.exit(1)

ss_file = options.ss

dir = options.dir
if dir:
	curr_dir = dir
else:
	curr_dir = os.getcwd()



# Check alignment and atom

if 	(options.alignment != '' and options.atomdir == '') or (options.alignment == '' and options.atomdir != ''):
	print('Error ! alignment and atom are not provided together. Exiting application...')
	sys.exit(1)

custom_restraints = ''
if options.restraints:
	custom_restraints = options.restraints


work_dir = curr_dir + '/' + target
if not os.path.exists(work_dir):
	os.makedirs(work_dir)


init_dir = work_dir + '/init_structure'
if not os.path.exists(init_dir):
	os.makedirs(init_dir)

sample_dir = work_dir + '/sampled_structure'
if not os.path.exists(sample_dir):
	os.makedirs(sample_dir)

###########################################################################################
# (1) Build extended structure from sequence
###########################################################################################
topology = IMP.atom.CHARMMTopology(IMP.atom.get_all_atom_CHARMM_parameters())
topology.add_sequence(sequence)
topology.apply_default_patches()


###########################################################################################
# (2) Load the model into IMP Hierarchy
###########################################################################################
m = IMP.Model()
h = topology.create_hierarchy(m)   ##### can we add secondary structure information to build extend structure, or add secondary structure angle restraints later
topology.add_atom_types(h)
topology.add_coordinates(h)
IMP.atom.add_radii(h) # Hierarchies in IMP must have radii
init_pdb = init_dir+'/'+target+'-init.pdb'
IMP.atom.write_pdb(h, init_pdb) # Write out the final structure to a PDB file
print("Writng initial structure to ",init_pdb) 

###########################################################################################
# (3) Load initial model
###########################################################################################

m = IMP.Model()
select1 = IMP.atom.OrPDBSelector(IMP.atom.CBetaPDBSelector(),IMP.atom.BackbonePDBSelector())
select2 = IMP.atom.OrPDBSelector(select1,IMP.atom.HydrogenPDBSelector())
prot = IMP.atom.read_pdb(init_pdb, m,select2)
#prot = IMP.atom.read_pdb(init_pdb, m)
res_model = IMP.atom.get_by_type(prot, IMP.atom.RESIDUE_TYPE)
atoms_model = IMP.atom.get_by_type(prot, IMP.atom.ATOM_TYPE)
chain_model = IMP.atom.get_by_type(prot, IMP.atom.CHAIN_TYPE)
if len(chain_model) !=1:
	print('Error ! More than one chain in the PDB structure. Exiting application...')
	sys.exit(-1)

print("Chain has", len(atoms_model), "atoms")
cont_model = IMP.container.ListSingletonContainer(atoms_model) # Get a list of all atoms in the model, and put it in a container

for atom in atoms_model:
	print(atom)

model_residues = {}
model_particle_index = {}
# Hydrogen or Nitrogen must be present for all atoms, in order to apply hydrogen bond restraints
for i in range(0,len(cont_model.get_particles())):
	p1 = cont_model.get_particles()[i]
	#get atom information
	p1_atom = IMP.atom.Atom(p1)
	p1_coord = IMP.core.XYZ(p1).get_coordinates() #(1.885, 68.105, 54.894)
	p1_atom_name = p1_atom.get_atom_type().get_string() #'N'
	het = p1_atom_name.startswith('HET:')
	if het:
		p1_atom_name = p1_atom_name[4:]
	p1_res = IMP.atom.get_residue(p1_atom) ##1 "SER"
	p1_resname = p1_res.get_name() #'SER'
	p1_seq_id = p1_res.get_index() #1
	IMP.core.XYZ(p1).set_coordinates_are_optimized(True)
	if p1_atom.get_atom_type() == IMP.atom.AtomType("CA"):
		model_residues[p1_seq_id] = p1_resname
	
	info = str(p1_seq_id)+'-'+p1_resname+'-'+p1_atom_name
	model_particle_index[info] = i # get particle index of atom in chain 

# In case of Proline, use N atom instead of H
for res_id in model_residues:
	p1_resname = model_residues[res_id]
	if str(res_id)+'-'+p1_resname+'-H' in model_particle_index:
		continue
	if str(res_id)+'-'+p1_resname+'-N' in model_particle_index:
		continue
	print('Error ! Something went wrong with residue ',res_id,':',p1_resname,' must have H or N for each residue!. Exiting application...')
	sys.exit(-1)


# Global variables for generating secondary structure restraints
SS_ATOMTYPE = {}
SS_ATOMTYPE['CA'] = 1
SS_ATOMTYPE['N'] = 1
SS_ATOMTYPE['C'] = 1
SS_ATOMTYPE['O'] = 1

SS_SHIFT = {}
SS_SHIFT['0'] = 1
SS_SHIFT['+1'] = 1
SS_SHIFT['-1'] = 1
res_dihe     = {};
res_strnd_OO = {};
res_dist     = {};
res_hbnd     = {};

load_ss_restraints(lamda, "ssrestraints.log");

def load_ss_restraints(lamda,log_reference){
	# T      Helix or Parallel or anti-parallel or Unknown Strand Type
	# A1_A2  Atom1-Atom2 pair
	# Ref    Hydrogen bonding connector atom (reference hbond connector)
	# N      Neighborhood residue shifting on the hbond connector of R2 side. For example, If R1:N and R2:O have hbond and S = +1, the restraint A1-A2 are for R1 and (R2+1)
	# Note: hbond distances are the distances between Nitrogen and Oxygen
	# Places to verify:
	# http://www.beta-sheet.org/page29/page51/page53/index.html
	# In this model, the HP sheet is composed of identical straight helical chains with phi = -122 degrees, psi = 135 degrees, and a slightly non-linear interchain H-bond angle delta of 170 degrees.
	# http://en.wikipedia.org/wiki/Alpha_helix
	# Residues in Î±-helices typically adopt backbone (Ï, Ï) dihedral angles around (-60Â°, -45Â°), as shown in the image at right
	# the H to O distance is about 2 Ã (0.20 nm

	# T A Mean Standard_deviation
	res_dihe["A PSI"] = "136.91 ".(lamda * 17.39);
	$res_dihe["A PHI"] = "-120.89 ".(lamda * 21.98);
	$res_dihe["P PSI"] = "130.96 ".(lamda * 16.66);
	$res_dihe["P PHI"] = "-115.00 ".(lamda * 20.31);
	$res_dihe["U PSI"] = "134.95 ".(lamda * 17.65);
	$res_dihe["U PHI"] = "-118.91 ".(lamda * 21.73);
	$res_dihe["H PSI"] = "-41.51 ".(lamda * 9.84);
	$res_dihe["H PHI"] = "-63.47 ".(lamda * 9.20);

	#T A1_A2 Ref N Mean Standard_deviation
	res_dist["A O-O O +1"]   = get_dist_neg_pos(7.73, 0.59, lamda);
	res_dist["A O-O O -1"]   = get_dist_neg_pos(4.84, 0.16, lamda);
	res_dist["A O-O O 0"]    = get_dist_neg_pos(3.57, 0.28, lamda);
	res_dist["A O-O H +1"]   = get_dist_neg_pos(7.76, 0.60, lamda);
	res_dist["A O-O H -1"]   = get_dist_neg_pos(4.90, 0.45, lamda);
	res_dist["A O-O H 0"]    = get_dist_neg_pos(3.58, 0.31, lamda);
	res_dist["A C-C O +1"]   = get_dist_neg_pos(7.66, 0.52, lamda);
	res_dist["A C-C O -1"]   = get_dist_neg_pos(4.80, 0.17, lamda);
	res_dist["A C-C O 0"]    = get_dist_neg_pos(4.96, 0.21, lamda);
	res_dist["A C-C H +1"]   = get_dist_neg_pos(7.65, 0.51, lamda);
	res_dist["A C-C H -1"]   = get_dist_neg_pos(4.85, 0.34, lamda);
	res_dist["A C-C H 0"]    = get_dist_neg_pos(4.96, 0.21, lamda);
	res_dist["A N-N O +1"]   = get_dist_neg_pos(5.09, 0.34, lamda);
	res_dist["A N-N O -1"]   = get_dist_neg_pos(6.86, 0.40, lamda);
	res_dist["A N-N O 0"]    = get_dist_neg_pos(4.42, 0.24, lamda);
	res_dist["A N-N H +1"]   = get_dist_neg_pos(5.04, 0.21, lamda);
	res_dist["A N-N H -1"]   = get_dist_neg_pos(6.85, 0.45, lamda);
	res_dist["A N-N H 0"]    = get_dist_neg_pos(4.43, 0.25, lamda);
	res_dist["A CA-CA O +1"] = get_dist_neg_pos(6.43, 0.41, lamda);
	res_dist["A CA-CA O -1"] = get_dist_neg_pos(5.67, 0.28, lamda);
	res_dist["A CA-CA O 0"]  = get_dist_neg_pos(5.26, 0.24, lamda);
	res_dist["A CA-CA H +1"] = get_dist_neg_pos(6.38, 0.36, lamda);
	res_dist["A CA-CA H -1"] = get_dist_neg_pos(5.71, 0.40, lamda);
	res_dist["A CA-CA H 0"]  = get_dist_neg_pos(5.27, 0.25, lamda);
	res_dist["P O-O O +1"]   = get_dist_neg_pos(7.90, 0.61, lamda);
	res_dist["P O-O O -1"]   = get_dist_neg_pos(4.86, 0.16, lamda);
	res_dist["P O-O O 0"]    = get_dist_neg_pos(3.78, 0.34, lamda);
	res_dist["P O-O H +1"]   = get_dist_neg_pos(4.92, 0.40, lamda);
	res_dist["P O-O H -1"]   = get_dist_neg_pos(8.02, 0.60, lamda);
	res_dist["P O-O H 0"]    = get_dist_neg_pos(3.78, 0.32, lamda);
	res_dist["P C-C O +1"]   = get_dist_neg_pos(8.03, 0.51, lamda);
	res_dist["P C-C O -1"]   = get_dist_neg_pos(4.82, 0.17, lamda);
	res_dist["P C-C O 0"]    = get_dist_neg_pos(5.21, 0.25, lamda);
	res_dist["P C-C H +1"]   = get_dist_neg_pos(4.88, 0.34, lamda);
	res_dist["P C-C H -1"]   = get_dist_neg_pos(7.87, 0.44, lamda);
	res_dist["P C-C H 0"]    = get_dist_neg_pos(5.22, 0.22, lamda);
	res_dist["P N-N O +1"]   = get_dist_neg_pos(8.14, 0.35, lamda);
	res_dist["P N-N O -1"]   = get_dist_neg_pos(4.86, 0.40, lamda);
	res_dist["P N-N O 0"]    = get_dist_neg_pos(5.13, 0.32, lamda);
	res_dist["P N-N H +1"]   = get_dist_neg_pos(4.80, 0.18, lamda);
	res_dist["P N-N H -1"]   = get_dist_neg_pos(7.54, 0.69, lamda);
	res_dist["P N-N H 0"]    = get_dist_neg_pos(5.10, 0.28, lamda);
	res_dist["P CA-CA O +1"] = get_dist_neg_pos(8.55, 0.37, lamda);
	res_dist["P CA-CA O -1"] = get_dist_neg_pos(4.90, 0.29, lamda);
	res_dist["P CA-CA O 0"]  = get_dist_neg_pos(6.21, 0.26, lamda);
	res_dist["P CA-CA H +1"] = get_dist_neg_pos(4.90, 0.28, lamda);
	res_dist["P CA-CA H -1"] = get_dist_neg_pos(7.49, 0.60, lamda);
	res_dist["P CA-CA H 0"]  = get_dist_neg_pos(6.24, 0.24, lamda);
	res_dist["H O-O O +1"]   = get_dist_neg_pos(8.40, 0.27, lamda);
	res_dist["H O-O O -1"]   = get_dist_neg_pos(4.99, 0.16, lamda);
	res_dist["H O-O O 0"]    = get_dist_neg_pos(6.12, 0.26, lamda);
	res_dist["H O-O H +1"]   = get_dist_neg_pos(5.03, 0.31, lamda);
	res_dist["H O-O H -1"]   = get_dist_neg_pos(8.43, 0.32, lamda);
	res_dist["H O-O H 0"]    = get_dist_neg_pos(6.12, 0.26, lamda);
	res_dist["H C-C O +1"]   = get_dist_neg_pos(8.16, 0.24, lamda);
	res_dist["H C-C O -1"]   = get_dist_neg_pos(4.87, 0.13, lamda);
	res_dist["H C-C O 0"]    = get_dist_neg_pos(6.09, 0.23, lamda);
	res_dist["H C-C H +1"]   = get_dist_neg_pos(4.89, 0.23, lamda);
	res_dist["H C-C H -1"]   = get_dist_neg_pos(8.17, 0.25, lamda);
	res_dist["H C-C H 0"]    = get_dist_neg_pos(6.09, 0.23, lamda);
	res_dist["H N-N O +1"]   = get_dist_neg_pos(8.07, 0.23, lamda);
	res_dist["H N-N O -1"]   = get_dist_neg_pos(4.84, 0.19, lamda);
	res_dist["H N-N O 0"]    = get_dist_neg_pos(6.10, 0.20, lamda);
	res_dist["H N-N H +1"]   = get_dist_neg_pos(4.81, 0.13, lamda);
	res_dist["H N-N H -1"]   = get_dist_neg_pos(8.08, 0.21, lamda);
	res_dist["H N-N H 0"]    = get_dist_neg_pos(6.10, 0.20, lamda);
	res_dist["H CA-CA O +1"] = get_dist_neg_pos(8.63, 0.28, lamda);
	res_dist["H CA-CA O -1"] = get_dist_neg_pos(5.13, 0.20, lamda);
	res_dist["H CA-CA O 0"]  = get_dist_neg_pos(6.16, 0.26, lamda);
	res_dist["H CA-CA H +1"] = get_dist_neg_pos(5.14, 0.21, lamda);
	res_dist["H CA-CA H -1"] = get_dist_neg_pos(8.64, 0.26, lamda);
	res_dist["H CA-CA H 0"]  = get_dist_neg_pos(6.16, 0.26, lamda);

	# T Mean Standard_deviation
	res_strnd_OO["A"] = get_dist_neg_pos(4.57, 0.30, lamda);
	res_strnd_OO["P"] = get_dist_neg_pos(4.57, 0.29, lamda);
	res_strnd_OO["U"] = get_dist_neg_pos(4.57, 0.30, lamda);

	# T Mean Standard_deviation
	res_hbnd["A"] = get_dist_neg_pos(2.92, 0.16, lamda);
	res_hbnd["P"] = get_dist_neg_pos(2.93, 0.16, lamda);
	res_hbnd["H"] = get_dist_neg_pos(2.99, 0.17, lamda);
	
	if not res_dihe:
		print('Error ! dihe restraints could not be loaded. Exiting application...')
		sys.exit(-1)
	if not res_strnd_OO:
		print('Error ! dstr restraints could not be loaded. Exiting application...')
		sys.exit(-1)
	if not res_dist:
		print('Error ! dist restraints could not be loaded. Exiting application...')
		sys.exit(-1)
	if not res_hbnd:
		print('Error ! hbnd restraints could not be loaded. Exiting application...')
		sys.exit(-1)

	with open(log_reference, 'w') as f1:
	content = "#load_ss_restraints\n";
	f1.write(content)
	
	for item in res_dihe:
		content = item+"\t"+res_dihe[item]+"\n";
		with open(log_reference, 'a') as f1:
			f1.write(content)

	for item in res_strnd_OO:
		content = item+"\t"+res_strnd_OO[item]+"\n";
		with open(log_reference, 'a') as f1:
			f1.write(content)

	for item in res_dist:
		content = item+"\t"+res_dist[item]+"\n";
		with open(log_reference, 'a') as f1:
			f1.write(content)
	
	for item in res_hbnd:
		content = item+"\t"+res_hbnd[item]+"\n";
		with open(log_reference, 'a') as f1:
			f1.write(content)

def get_dist_neg_pos(mean, devi,lamda):
	lamda_devi = round(lamda*devi, 2)
	info = mean + ' ' + lamda_devi + ' ' + lamda_devi
	return info

def print2file(file,message,newline="\n"):
	$newline = "\n" if not defined $newline;
	if os.path.isfile(file):
		with open("ssrestraints.log", 'a') as f1:
			f1.write(message)
	else:
		with open("ssrestraints.log", 'w') as f1:
			f1.write(message)
	
}

def print_helix_restraints:
	res_sec = {}
	for i in range(0, len(ss_sequence)):
		ss_char = ss_sequence[i:i+1]
		if ss_char == 'H':
			res_sec[i+1] = ss_char
	
	if res_sec:
		print2file("ssrestraints.log", "write helix tbl restraints");
		for i in sorted(res_sec.keys()):
			PHI_buff = re.split(" +",res_dihe["H PHI"])
			PSI_buff = re.split(" +",res_dihe["H PSI"])
			if len(PHI_buff) != 2:
				print("The PHI_buff value is strange: ",PHI_buff)
				sys.exit(-1)
			if len(PSI_buff) != 2:
				print("The PSI_buff value is strange: ",PSI_buff)
				sys.exit(-1)
			# 9/1/2014: If phi angle is removed from the pre-first residue, the first residue cannot form helix most of the times. Checked in 4/5 proteins and 2 dozen helices.
			# So, adding the pre-first phi angle as well (by removing the condition for  res_sec{$i-1} to exist)
			
			if temp_char not in aa_one2index.keys():
				print('Error ! The amino acid ',temp_char,' not standard. Exiting application...')
				sys.exit(-1)
			
			target_aa_3letter = aa_index2three[aa_one2index[target_char]]
			temp_aa_3letter = aa_index2three[aa_one2index[temp_char]]
			
			if (i-1) in residues:
				C1 = str(i-1)+'-'+aa_index2three[aa_one2index[residues[i-1]]]+'-C'
				N2 = str(i)+'-'+aa_index2three[aa_one2index[residues[i]]]+'-N'
				CA2 = str(i)+'-'+aa_index2three[aa_one2index[residues[i]]]+'-CA'
				C2 = str(i)+'-'+aa_index2three[aa_one2index[residues[i]]]+'-C'
				content = C1 + "\t" + N2 + "\t" + CA2 + "\t" + C2  + str(5.0) + "\t" + str(PHI_buff[0]) + "\t" + str(PHI_buff[1]) + "\t" +  str(2) + "\t!helix phi"
				print2file("dihedral.tbl", content)
			# 9/1/2014: Even if we don't have PSI for the last residue, the last residue form helix, almost in all cases.
			# 9/2/2014: In some cases like target Tc767, only 106 helix residues were formed while the input is 111. And all of it is because of the psi angle at the end.
			# So, adding the post-last psi angle as well (by removing the condition for res_sec{$i+1} to exist)
			if (i+1) in residues:
				N1 = str(i)+'-'+aa_index2three[aa_one2index[residues[i]]]+'-N'
				CA1 = str(i)+'-'+aa_index2three[aa_one2index[residues[i]]]+'-CA'
				C1 = str(i)+'-'+aa_index2three[aa_one2index[residues[i]]]+'-C'
				N2 = str(i+1)+'-'+aa_index2three[aa_one2index[residues[i+1]]]+'-N'
				content = N1 + "\t" + CA1 + "\t" + C1 + "\t" + N2  + str(5.0) + "\t" + str(PSI_buff[0]) + "\t" + str(PSI_buff[1]) + "\t" +  str(2) + "\t!helix psi"
				print2file("dihedral.tbl", content)				
		
		for i in sorted(res_sec.keys()):
			if (i+1) not in res_sec:
				continue
			if (i+2) not in res_sec:
				continue
			if (i+3) not in res_sec:
				continue
			if (i+4) not in res_sec:
				continue
			HR_buff = re.split(" +",res_hbnd["H"])
			if len(HR_buff) != 3:
				print("The HR_buff value is strange: ",HR_buff)
				sys.exit(-1)
			# In case of Proline, use N atom instead of H
			HATOM = "H";
			HR_buff[0] -= 1.0
			if residues[$i+4] == "P":
				HR_buff[0] += 1.0;
				HATOM  = "N";
			
			O1 = str(i)+'-'+aa_index2three[aa_one2index[residues[i]]]+'-O'
			N4 = str(i+4)+'-'+aa_index2three[aa_one2index[residues[i+4]]]+'-' + HATOM
			content = O1 + "\t" + N4 + "\t" + str(HR_buff[0]) + "\t" + str(HR_buff[1]) + "\t" + str(HR_buff[2]) + "\t!helix"
			print2file("hbond.tbl", (content));
		
		for i in sorted(res_sec.keys()):
			if (i+1) not in res_sec:
				continue
			if (i+2) not in res_sec:
				continue
			if (i+3) not in res_sec:
				continue
			if (i+4) not in res_sec:
				continue
			for A in sorted(SS_ATOMTYPE.keys()):
				for SH in sorted(SS_SHIFT.keys()):
					AR_buff = re.split(" +",res_dist["H "+A+"-"+A+" O "+SH])
					if len(AR_buff) != 3:
						print("The AR_buff value is strange: ",AR_buff)
						sys.exit(-1)
					# found restraints even for non-helix SS
					if (i+4+int(SH)) not in res_sec:
						continue
					#confess ":(" if not defined ($i and $A and ($i+4+$SH) and $AR[0] and $AR[1] and $AR[2]);
					
					A1 = str(i)+'-'+aa_index2three[aa_one2index[residues[i]]]+'-'+str(A)
					A5 = str(i+4+int(SH))+'-'+aa_index2three[aa_one2index[residues[i+4+int(SH)]]]+'-'+str(A)
					content = A1 + "\t" + A5 + "\t" + str(AR_buff[0]) + "\t" + str(AR_buff[1]) + "\t" + str(AR_buff[2]) + "\t!helix"
					print2file("ssnoe.tbl", (content));
	else:
		print2file("ssrestraints.log", "no helix predictions!");
	
def strand_count(file_ss){
	confess "ERROR! SS file $file_ss does not exist!" if not -f $file_ss;
	f = open(file_ss, 'r')	
	ss_seq = f.readlines()	
	f.close()	
	# removing the trailing "\n" and any header lines
	ss_seq = [line.strip() for line in ss_seq if not '>' in line]
	ss_seq = ''.join( ss_seq )
	count = 0
	for i in range(0, len(ss_seq)):
		if ss_sequence[i:i+1] == 'E':
			continue
		if i>0 and i<len(ss_seq)-1 and ss_sequence[i-1:i] == 'E' and ss_sequence[i:i+1] == 'E' and ss_sequence[i+1:i+2] == 'E':
			count +=1
	
	return count;
}


def strand_and_sheet_tbl(file_ss,file_pair,file_pairing_hbond):

	res_ss = {}
	unpaired_residues = {}
	res_ssE = {}
	for i in range(0, len(ss_sequence)):
		ss_char = ss_sequence[i:i+1]
		res_ss[i+1] = ss_char
		unpaired_residues[i+1] = ss_char
		if ss_char == 'E':
			res_ssE[i+1] = ss_char
			
	paired_residues = {};
	hbonds = {};
	if ($file_pair){
		%paired_residues = paired_residues($file_pair);
		foreach (sort keys %unpaired_residues){
			delete $unpaired_residues{$_} if $unpaired_residues{$_} ne "E";
		}
		foreach (sort keys %unpaired_residues){
			delete $unpaired_residues{$_} if defined $paired_residues{$_};
		}
		%hbonds = load_hbonds($file_pairing_hbond);
		confess ":(" if not scalar %paired_residues;
		confess ":(" if not scalar %hbonds;
		foreach (sort keys %hbonds){
			my @H = split /\s+/, $_;
			my @HR = split /\s+/, $res_hbnd{$hbonds{$_}};
			confess ":( distance not defined ".$hbonds{$_} if not (defined $HR[0] and defined $HR[1] and defined $HR[2]);
			# In case of Proline, use N atom instead of H
			$HR[0] -= 1.0;
			if(not defined $defined_atoms{$H[0]." ".$H[1]}){
				confess "ERROR! N must be defined when H is not for ".$H[0] if not defined $defined_atoms{$H[0]." N"};
				$HR[0] += 1.0;
				$H[1]  = "N";
			}
			if(not defined $defined_atoms{$H[2]." ".$H[3]}){
				confess "ERROR! N must be defined when H is not for ".$H[2] if not defined $defined_atoms{$H[2]." N"};
				$HR[0] += 1.0;
				$H[3]  = "N";
			}
			print2file("hbond.tbl", (sprintf "assign (resid %3d and name %1s) (resid %3d and name %1s) %4s %4s %4s !sheet", $H[0], $H[1], $H[2], $H[3], $HR[0], $HR[1], $HR[2]));
		}
		foreach my $hb (sort keys %hbonds){
			my @H = split /\s+/, $hb;
			my @hbondConnectors = ( $H[0]." ".$H[1]." ".$H[2], $H[2]." ".$H[3]." ".$H[0]); 
			foreach (@hbondConnectors){
				my @HBC = split /\s+/, $_;
				foreach my $A (sort keys %ATOMTYPE){
					foreach my $S (sort keys %SHIFT){
						# A   O-O   O -1 
						my $distances = $res_dist{$hbonds{$hb}." ".$A."-".$A." ".$HBC[1]." ".$S};
						my @DIST = split /\s+/, $distances;
						confess ":( distance not defined ".$hbonds{$hb}." ".$A."-".$A." ".$HBC[1]." ".$S if not defined $DIST[2];
						next if not defined $paired_residues{($HBC[2]+$S)};
						print2file("ssnoe.tbl", (sprintf "assign (resid %3d and name %2s) (resid %3d and name %2s) %2.2f %2.2f %2.2f !sheet", $HBC[0], $A, ($HBC[2]+$S), $A, $DIST[0], $DIST[1], $DIST[2]));
					}
				}
			}
		}
	}
	# Identify the strands that are not used for pairing and generate generic dihedral restraints for them
	foreach my $i (sort {$a <=> $b} keys %res_ssE){
		my @SPHI = ();
		my @SPSI = ();
		my $strand_type = "unpaired E residue";
		if (defined $paired_residues{$i}){
			@SPHI = split /\s+/, $res_dihe{$paired_residues{$i}." PHI"};
			@SPSI = split /\s+/, $res_dihe{$paired_residues{$i}." PSI"};
			$strand_type = "paired E residue";
		}
		else{
			@SPHI = split /\s+/, $res_dihe{"U PHI"};
			@SPSI = split /\s+/, $res_dihe{"U PSI"};
		}
		if (defined $res_ss{$i-1} and $res_ss{$i-1} eq "E"){
			print2file("dihedral.tbl", (sprintf "assign (resid %3d and name c) (resid %3d and name  n) (resid %3d and name ca) (resid %3d and name c) 5.0 %7s %7s 2 !$strand_type phi", $i-1, $i, $i, $i, $SPHI[0], $SPHI[1]));
		}
		if (defined $res_ss{$i+1} and $res_ss{$i+1} eq "E"){
			print2file("dihedral.tbl", (sprintf "assign (resid %3d and name n) (resid %3d and name ca) (resid %3d and name  c) (resid %3d and name n) 5.0 %7s %7s 2 !$strand_type psi", $i, $i, $i, $i+1, $SPSI[0], $SPSI[1]));
		}
	}
	# Identify the strands that are not used for pairing and generate generic restraints for them
	foreach my $i (sort {$a <=> $b} keys %res_ssE){
		my @SD = ();
		my $strand_type = "unpaired E residue";
		if (defined $paired_residues{$i}){
			@SD = split /\s+/, $res_strnd_OO{$paired_residues{$i}};
			confess ":(" if (!$SD[0] or !$SD[1] or !$SD[2]);
			$strand_type = "paired E residue";
		}
		else{
			@SD = split /\s+/, $res_strnd_OO{"U"};
			confess ":(" if (!$SD[0] or !$SD[1] or !$SD[2]);
		}
		next if not defined $res_ssE{$i+1};
		next if $res_ssE{$i+1} ne "E";
		print2file("ssnoe.tbl", (sprintf "assign (resid %3d and name %2s) (resid %3d and name %2s) %.2f %.2f %.2f !$strand_type", $i, "O", $i+1, "O", $SD[0], $SD[1], $SD[2]));
	}

def sec_restraints():
	# helix restraints; start writing to the files hbond.tbl, ssnoe.tbl and dihedral.tbl
	print_helix_restraints();
	# strand and/or sheet restraints
	if (strand_count(ss_file) == 0){
		print2file("ssrestraints.log", "no strand restraints");
		return;
	}
	if (strand_count(ss_file) == 1){
		print("\nWARNING! only 1 strand! please check your secondary structure file!")
		print2file("ssrestraints.log", "WARNING! only 1 strand! please check your secondary structure file!");
		return;
	}
	
	pair_hbonds = {}		
	# continue to write to hbond.tbl, ssnoe.tbl and dihedral.tbl
	strand_and_sheet_tbl($file_ss, undef, undef);

###########################################################################################
# (4) load the template structure and get information for all atoms
###########################################################################################

## load template information from alignments
if options.alignment and options.atomdir:

	num = 0
	template_name = {}
	template_sequence = {}
	template_region = {}
	weight = {}
	f = open(options.alignment, 'r')    # open the alignment file
	while True:
		line1 = f.readline()
		if not line1:
			break
		line2 = f.readline()
		line3 = f.readline()
		line4 = f.readline()
		line5 = f.readline()
		if line3[:9] == "structure":
			num += 1
			info =  line1[line1.rindex('='):]
			buff = re.split("\t+",info.strip())
			if len(buff) == 1:
				buff = re.split(" +",info.strip())
				parent_rec = re.sub("[^0-9A-Za-z]", "",buff[1])
				e_val = float(re.sub("[^0-9.e+-]", "",buff[4]))
			else:
				parent_rec = re.sub("[^0-9A-Za-z]", "",buff[0])
				e_val = float(re.sub("[^0-9.e+-]", "",buff[3]))
			
			buff = re.split(":",line3.strip())
			temp_start = buff[2].replace(' ', '')
			temp_end = buff[4].replace(' ', '')
			#parent_id = parent_rec.strip()[0:4]
			#parent_chain = parent_rec.strip()[4:5]
			#if parent_chain.strip() == '':
			#	parent = str(parent_id.lower())
			#else:
			#	parent = str(parent_id.lower()) + '_' + str(parent_chain.upper())
			#if e_val <=  self.e_val_threshold:
			#self.parent.append(parent)
			template_name[num] = parent_rec
			template_sequence[num] = line4.strip()[:-1]
			template_region[num] = str(temp_start)+'-'+str(temp_end)
		else:
			target_sequence = line4.strip()[:-1]
	
	## check alignment sequence is same as fasta sequence 
	target_pir_seq = target_sequence;
	target_pir_seq = target_pir_seq.replace('-', '') 
	#print(target_sequence)
	#print(target_pir_seq)
	if target_pir_seq != sequence:
		print('Error ! The sequence in alignment is not same as fasta sequence. Exiting application...')
		sys.exit(-1)
	

	#### get distance restraints for N-CA, CA-C, C-O, CA-CB, CA-CA, CB-CB
	model_residues = {}
	model_particle_index = {}


	## check each template 
	m_native = IMP.Model()
	target_index2AtomCoord = {}
	for temp_indx in template_sequence:
		temp_seq = template_sequence[temp_indx]
		temp_name = template_name[temp_indx]
		temp_region = template_region[temp_indx]
		atomfile = options.atomdir + '/' +temp_name+'.atm'
		#print(target_sequence)
		#print(temp_seq)		

		for i in range(0,len(cont_model.get_particles())):
			p1 = cont_model.get_particles()[i]
			#get atom information
			p1_atom = IMP.atom.Atom(p1)
			p1_coord = IMP.core.XYZ(p1).get_coordinates() #(1.885, 68.105, 54.894)
			p1_atom_name = p1_atom.get_atom_type().get_string() #'N'
			het = p1_atom_name.startswith('HET:')
			if het:
				p1_atom_name = p1_atom_name[4:]
			p1_res = IMP.atom.get_residue(p1_atom) ##1 "SER"
			p1_resname = p1_res.get_name() #'SER'
			p1_seq_id = p1_res.get_index() #1
			IMP.core.XYZ(p1).set_coordinates_are_optimized(True)
			if p1_atom.get_atom_type() == IMP.atom.AtomType("CA"):
				model_residues[p1_seq_id] = p1_resname
			
			info = str(p1_seq_id)+'-'+p1_resname+'-'+p1_atom_name+'-'+str(temp_indx)
			model_particle_index[info] = i # get particle index of atom in chain 
		
		prot_native = IMP.atom.read_pdb(atomfile, m_native) 
		atoms_native = IMP.atom.get_by_type(prot_native, IMP.atom.ATOM_TYPE)
		cont_native = IMP.container.ListSingletonContainer(atoms_native)

		
		#### get information for N,CA,C,O,CB from native structure

		index2ResidueName={}
		residue2Atoms={}
		index2AtomCoord={}
		for i in range(0,len(cont_native.get_particles())):
			p1 = cont_native.get_particles()[i]
			#get atom information
			p1_atom = IMP.atom.Atom(p1)
			p1_coord = IMP.core.XYZ(p1).get_coordinates() #(1.885, 68.105, 54.894)
			p1_atom_name = p1_atom.get_atom_type().get_string() #'N'
			het = p1_atom_name.startswith('HET:')
			if het:
				p1_atom_name = p1_atom_name[4:]
			p1_res = IMP.atom.get_residue(p1_atom) ##1 "SER"
			p1_resname = p1_res.get_name() #'SER'
			p1_seq_id = p1_res.get_index() #1
			if p1_atom.get_atom_type() == IMP.atom.AtomType("CA"):
				index2ResidueName[p1_seq_id] = p1_resname
			
			if str(p1_seq_id)+'-'+p1_resname in residue2Atoms.keys():
				residue2Atoms[str(p1_seq_id)+'-'+p1_resname].append(p1_atom_name)
			else:
				residue2Atoms[str(p1_seq_id)+'-'+p1_resname]=[]
				residue2Atoms[str(p1_seq_id)+'-'+p1_resname].append(p1_atom_name)
			index2AtomCoord[str(p1_seq_id)+'-'+p1_resname+'-'+p1_atom_name] = IMP.core.XYZ(p1)
		
		if len(target_sequence) != len(temp_seq):
			#print(target_sequence)
			#print(temp_seq)
			print('Error ! The template seq size is not same as target sequence. Exiting application...')
			sys.exit(-1)
		
		
		
		buff = re.split("-",temp_region.strip())
		target_res_num = 0
		temp_res_num = int(buff[0])-1
		temp2target_align = {}
		for i in range(0, len(target_sequence)):
			target_char = target_sequence[i:i+1]
			temp_char = temp_seq[i:i+1]
			
			if temp_char.strip() != "-":
				temp_res_num += 1
			if target_char.strip() != "-":
				target_res_num += 1
				if temp_char.strip() != "-":
					## record to get coordinate from template
					if temp_char not in aa_one2index.keys():
						print('Error ! The amino acid ',temp_char,' not standard. Exiting application...')
						sys.exit(-1)
					
					target_aa_3letter = aa_index2three[aa_one2index[target_char]]
					temp_aa_3letter = aa_index2three[aa_one2index[temp_char]]
					if temp_aa_3letter != index2ResidueName[temp_res_num]:
						print('Error ! The template amino acid in alignmnet ',temp_aa_3letter,' not same as in pdb ',index2ResidueName[temp_res_num],' in position ',temp_res_num,'. Exiting application...')
						sys.exit(-1)
					
					if target_aa_3letter != model_residues[target_res_num]:
						print('Error ! The target amino acid in alignmnet ',target_aa_3letter,' not same as in pdb ',model_residues[target_res_num],' in position ',temp_res_num,'. Exiting application...')
						sys.exit(-1)
					#print(str(temp_res_num)+'-'+temp_aa_3letter + '-->' +str(target_res_num)+'-'+target_aa_3letter)
					
					if str(temp_res_num)+'-'+temp_aa_3letter not in residue2Atoms:
						print('Error ! Failed to find atoms for ',str(temp_res_num),'-',temp_aa_3letter,' in template structures. Exiting application...')
						sys.exit(-1)
					atoms_array = residue2Atoms[str(temp_res_num)+'-'+temp_aa_3letter]
					for atom in atoms_array:
						if  str(temp_res_num)+'-'+temp_aa_3letter + '-'+atom not in index2AtomCoord:
							print('Error ! Failed to find atoms for ',str(temp_res_num),'-',temp_aa_3letter,'-',atom,' in template structures. Exiting application...')
							sys.exit(-1)
						o_info = str(target_res_num)+'-'+target_aa_3letter+ '-'+atom+'-'+str(temp_indx)
						#if target_res_num < 5:
						#	print(o_info,'->',index2AtomCoord[str(temp_res_num)+'-'+temp_aa_3letter + '-'+atom])
						if str(target_res_num)+'-'+target_aa_3letter+ '-'+atom+'-'+str(temp_indx) in model_particle_index:
							target_index2AtomCoord[str(target_res_num)+'-'+target_aa_3letter+ '-'+atom+'-'+str(temp_indx)]=index2AtomCoord[str(temp_res_num)+'-'+temp_aa_3letter + '-'+atom]			
	



	###########################################################################################
	# (5) get distance restraints for N-CA, CA-C, C-O, CA-CB, CA-CA, CB-CB
	###########################################################################################


	residue_array = sorted(model_residues.keys())
	restraints_list = []
	for temp_indx in template_sequence:
		print("Processing restraints from template ",temp_indx)
		for i in range(0,len(residue_array)):
			# get N-CA, CA-C, C-O, CA-CB
			res1_indx = residue_array[i]
			res1_name = model_residues[res1_indx]
			
			res1_N_atom = str(res1_indx)+'-'+res1_name+'-N'+'-'+str(temp_indx)
			res1_CA_atom = str(res1_indx)+'-'+res1_name+'-CA'+'-'+str(temp_indx)
			res1_C_atom = str(res1_indx)+'-'+res1_name+'-C'+'-'+str(temp_indx)
			res1_O_atom = str(res1_indx)+'-'+res1_name+'-O'+'-'+str(temp_indx)
			res1_CB_atom = str(res1_indx)+'-'+res1_name+'-CB'+'-'+str(temp_indx)
			
			# get native coordinates, suppose the template structure is provided
			
			for j in range(i+1,len(residue_array)):
				res2_indx = residue_array[j]
				res2_name = model_residues[res2_indx]
				
				res2_CA_atom = str(res2_indx)+'-'+res2_name+'-CA'+'-'+str(temp_indx)
				res2_CB_atom = str(res2_indx)+'-'+res2_name+'-CB'+'-'+str(temp_indx)
				res2_O_atom = str(res2_indx)+'-'+res2_name+'-O'+'-'+str(temp_indx)
				res2_N_atom = str(res2_indx)+'-'+res2_name+'-N'+'-'+str(temp_indx)
				
				
				# get CA-CA
				if res1_CA_atom in target_index2AtomCoord.keys() and res2_CA_atom in target_index2AtomCoord.keys():
					#print('Adding information for ',res1_CA_atom,' and ',res2_CA_atom)
					res1_CA_atom_coord = target_index2AtomCoord[res1_CA_atom]
					res2_CA_atom_coord = target_index2AtomCoord[res2_CA_atom]
					#print("res1_CA_atom_coord: ",res1_CA_atom_coord)
					#print("res2_CA_atom_coord: ",res2_CA_atom_coord)
					x1,y1,z1 = [res1_CA_atom_coord.get_x(),res1_CA_atom_coord.get_y(),res1_CA_atom_coord.get_z()]
					x2,y2,z2 = [res2_CA_atom_coord.get_x(),res2_CA_atom_coord.get_y(),res2_CA_atom_coord.get_z()]
					dist = np.linalg.norm([x1-x2,y1-y2,z1-z2])
					
					# get the particle index in model 
					p1 = cont_model.get_particles()[model_particle_index[res1_CA_atom]]
					p2 = cont_model.get_particles()[model_particle_index[res2_CA_atom]]
					f = IMP.core.Harmonic(dist, 1.0)
					s = IMP.core.DistancePairScore(f)
					r = IMP.core.PairRestraint(m, s, (p1, p2))
					restraints_list.append(r)
				
				# get CB-CB
				if res1_CB_atom in target_index2AtomCoord.keys() and res2_CB_atom in target_index2AtomCoord.keys():
					res1_CB_atom_coord = target_index2AtomCoord[res1_CB_atom]
					res2_CB_atom_coord = target_index2AtomCoord[res2_CB_atom]
					x1,y1,z1 = [res1_CB_atom_coord.get_x(),res1_CB_atom_coord.get_y(),res1_CB_atom_coord.get_z()]
					x2,y2,z2 = [res2_CB_atom_coord.get_x(),res2_CB_atom_coord.get_y(),res2_CB_atom_coord.get_z()]
					dist = np.linalg.norm([x1-x2,y1-y2,z1-z2])
					
					# get the particle index in model 
					p1 = cont_model.get_particles()[model_particle_index[res1_CB_atom]]
					p2 = cont_model.get_particles()[model_particle_index[res2_CB_atom]]
					f = IMP.core.Harmonic(dist, 1.0)
					s = IMP.core.DistancePairScore(f)
					r = IMP.core.PairRestraint(m, s, (p1, p2))
					restraints_list.append(r)
				
				
				# this is very useful for secondary structure folding. get N-O to get hydrogen bond, 
				#check confold how to add all N-O. pulchar also does post-hydrogen bond optimization.  
				#We don't need all N-O which will cause large energy, we only need small part N-O, check confold
				'''
				if res1_N_atom in target_index2AtomCoord.keys() and res2_O_atom in target_index2AtomCoord.keys():
					res1_N_atom_coord = target_index2AtomCoord[res1_N_atom]
					res2_O_atom_coord = target_index2AtomCoord[res2_O_atom]
					x1,y1,z1 = [res1_N_atom_coord.get_x(),res1_N_atom_coord.get_y(),res1_N_atom_coord.get_z()]
					x2,y2,z2 = [res2_O_atom_coord.get_x(),res2_O_atom_coord.get_y(),res2_O_atom_coord.get_z()]
					dist = np.linalg.norm([x1-x2,y1-y2,z1-z2])
					
					# get the particle index in model 
					p1 = cont_model.get_particles()[model_particle_index[res1_N_atom]]
					p2 = cont_model.get_particles()[model_particle_index[res2_O_atom]]
					f = IMP.core.Harmonic(dist, 1.0)
					s = IMP.core.DistancePairScore(f)
					r = IMP.core.PairRestraint(m, s, (p1, p2))
					restraints_list.append(r)
				'''
				
				if res1_O_atom in target_index2AtomCoord.keys() and res2_N_atom in target_index2AtomCoord.keys() and (res2_indx-res1_indx ==4):
					res1_O_atom_coord = target_index2AtomCoord[res1_O_atom]
					res2_N_atom_coord = target_index2AtomCoord[res2_N_atom]
					x1,y1,z1 = [res1_O_atom_coord.get_x(),res1_O_atom_coord.get_y(),res1_O_atom_coord.get_z()]
					x2,y2,z2 = [res2_N_atom_coord.get_x(),res2_N_atom_coord.get_y(),res2_N_atom_coord.get_z()]
					dist = np.linalg.norm([x1-x2,y1-y2,z1-z2])
					
					# get the particle index in model 
					p1 = cont_model.get_particles()[model_particle_index[res1_O_atom]]
					p2 = cont_model.get_particles()[model_particle_index[res2_N_atom]]
					f = IMP.core.Harmonic(dist, 1.0)
					s = IMP.core.DistancePairScore(f)
					r = IMP.core.PairRestraint(m, s, (p1, p2))
					restraints_list.append(r)
elif options.restraints:
	print("Loading custom restraints")
	# 2-LYS-CA-1 53-VAL-CA-1 distance 5.1234
	f = open(options.restraints, 'r')	
	restraints_contenst = f.readlines()	
	f.close()	

	model_residues = {}
	model_particle_index = {}
	for i in range(0,len(cont_model.get_particles())):
		p1 = cont_model.get_particles()[i]
		#get atom information
		p1_atom = IMP.atom.Atom(p1)
		p1_coord = IMP.core.XYZ(p1).get_coordinates() #(1.885, 68.105, 54.894)
		p1_atom_name = p1_atom.get_atom_type().get_string() #'N'
		het = p1_atom_name.startswith('HET:')
		if het:
			p1_atom_name = p1_atom_name[4:]
		p1_res = IMP.atom.get_residue(p1_atom) ##1 "SER"
		p1_resname = p1_res.get_name() #'SER'
		p1_seq_id = p1_res.get_index() #1
		IMP.core.XYZ(p1).set_coordinates_are_optimized(True)
		if p1_atom.get_atom_type() == IMP.atom.AtomType("CA"):
			model_residues[p1_seq_id] = p1_resname
		
		info = str(p1_seq_id)+'-'+p1_resname+'-'+p1_atom_name
		model_particle_index[info] = i # get particle index of atom in chain 
	
	restraints_list = []
	for line in restraints_contenst:
		if '#' in line:
			continue
		buff = re.split("\t+",line.strip())
		
		res1 = buff[0]
		res2 = buff[1]
		re_type = buff[2]
		re_value = float(buff[3])
		
		if res1 in model_particle_index and res2 in model_particle_index and re_type == 'distance':
			# get the particle index in model 
			p1 = cont_model.get_particles()[model_particle_index[res1]]
			p2 = cont_model.get_particles()[model_particle_index[res2]]
			f = IMP.core.Harmonic(re_value, 1.0)
			s = IMP.core.DistancePairScore(f)
			r = IMP.core.PairRestraint(m, s, (p1, p2))
			restraints_list.append(r)
		else:
			print("The following restraint sources not in model: ",res1," and ",res2)
else:
	print('Error ! No restrains are provided. Exiting application...')
	sys.exit(-1)
	
#### check using the predicted distance	
#### use predicted CB-CB distance,  
#### add secondary structure bond
#### in future, we can add predicted dihedral angles, predicted CA-CA	

###########################################################################################
# (6) Charmm forcefield
###########################################################################################


# Read in the CHARMM heavy atom topology and parameter files
ff = IMP.atom.get_heavy_atom_CHARMM_parameters()

# Using the CHARMM libraries, determine the ideal topology (atoms and their
# connectivity) for the PDB file's primary sequence
topology = ff.create_topology(prot)

# Typically this modifies the C and N termini of each chain in the protein by
# applying the CHARMM CTER and NTER patches. Patches can also be manually
# applied at this point, e.g. to add disulfide bridges.
topology.apply_default_patches()

# Make the PDB file conform with the topology; i.e. if it contains extra
# atoms that are not in the CHARMM topology file, remove them; if it is
# missing atoms (e.g. sidechains, hydrogens) that are in the CHARMM topology,
# add them and construct their Cartesian coordinates from internal coordinate
# information.
topology.setup_hierarchy(prot)

# Set up and evaluate the stereochemical part (bonds, angles, dihedrals,
# impropers) of the CHARMM forcefield
# or check atom/charmm_forcefield_verbose.py for customization
r1 = IMP.atom.CHARMMStereochemistryRestraint(prot, topology)
#m.add_restraint(r)

# Add non-bonded interaction (in this case, Lennard-Jones). This needs to
# know the radii and well depths for each atom, so add them from the forcefield
# (they can also be assigned manually using the XYZR or LennardJones
# decorators):
ff.add_radii(prot)
ff.add_well_depths(prot)


### add stereo can make CA and side-chain atoms optimized together, very important.
restraints_list.append(r1)

print('###########################################################################################')
print('# (7) Basic Optimization and Chain')
print('###########################################################################################')

# Optimize the x,y,z coordinates of both particles with conjugate gradients
s = IMP.core.ConjugateGradients(m)
#sf = IMP.core.RestraintsScoringFunction([br,r], "scoring function")
sf = IMP.core.RestraintsScoringFunction(restraints_list, "scoring function")

# the box to perform everything
s.set_scoring_function(sf)
#IMP.set_log_level(IMP.TERSE)

rotamer_lib='/data/commons/tools/IMP_tools/rotamer/ALL.bbdep.rotamers.lib'
rl = IMP.rotamer.RotamerLibrary()
rl.read_library_file(rotamer_lib)
rc = IMP.rotamer.RotamerCalculator(rl)

min_energy = 1000000000
min_info = ''
for i in range(0,10):
	s.optimize(100)
	
	energy = sf.evaluate(False)
	## can apply simulated annealing here
	if energy < min_energy:
		min_energy = energy
		print("Epoch: ",i,": ",min_energy)
		min_info = "Epoch: "+str(i)+": "+str(min_energy)
		
		'''
		print("before rotamer: ",sf.evaluate(False))
		IMP.atom.write_pdb(prot, '3BFO-B-epoch'+str(i)+'-noRotamer.pdb')
		
		## add backbone-dependent rotamer library
		mh = IMP.atom.get_by_type(prot, IMP.atom.RESIDUE_TYPE)
		# get the most probable rotamers
		rotamers = list()
		for h in mh:
			rd = IMP.atom.Residue(h)
			rr = rc.get_rotamer(rd, 0.01)
			rotamers.append((rd, rr))
		
		# now set the coordinates of all atoms in the residues to the rotated
		# coordinates
		for rd, rr in rotamers:
			for h in IMP.atom.get_by_type(rd, IMP.atom.ATOM_TYPE):
				at = IMP.atom.Atom(h)
				at_t = at.get_atom_type()
				if rr.get_atom_exists(at_t):
					# some atoms might not be rotated
					idx = min(rr.get_number_of_cases(at_t) - 1, 1)
					v = rr.get_coordinates(idx, at_t)
					xyz = IMP.core.XYZ(at)
					xyz.set_coordinates(v)
		
		print("after rotamer: ",sf.evaluate(False))
		## question, why rotamer increase the energy?
		IMP.atom.write_pdb(prot, '3BFO-B-epoch'+str(i)+'-withRotamer.pdb')
		'''
		out_pdb = sample_dir+'/'+target+'-epoch'+str(i)+'.pdb'
		IMP.atom.write_pdb(prot, out_pdb)
		#pulchra_cmd = '/data/jh7x3/multicom_github/multicom/tools/pulchra304/pulchra 3BFO-B-epoch'+str(i)+'.pdb'
		#os.system(pulchra_cmd)
	
print(min_info)


'''


m = IMP.Model()

#prot = IMP.atom.read_pdb(IMP.atom.get_example_path("example_protein.pdb"), m)

#####  build extend structure 


##### load true bond length, angle, residue distance 

##### load modeller restarints, steric, van der waasls, refer to /data/commons/tools/IMP_tools/IMP2.6/doc/examples/modeller/load_modeller_model.py 


##### add modeller restrants into imp 

##### add our dihedral, angular and distance restraints into imp
#modmodel.restraints.make(sel, restraint_type='STEREO', spline_on_site=False)
#https://salilab.org/modeller/9v7/manual/node196.html
#https://salilab.org/modeller/9.21/examples/automodel/model-addrsr.py


## the idea to convert secondary structure to dihedral constraints 
## (1) first load secodnary structure into dihedral  using https://salilab.org/modeller/9.21/examples/automodel/model-addrsr.py
## (2) get dihedral constratins using  modmodel.restraints.make(sel, restraint_type='dehidral', spline_on_site=False)


##### optimize 


##### write pdb
'''

'''
IMP.atom.add_bonds(prot)
bds = IMP.atom.get_internal_bonds(prot)
bl = IMP.container.ListSingletonContainer(m, bds)
h = IMP.core.Harmonic(0, 1)
bs = IMP.atom.BondSingletonScore(h)
br = IMP.container.SingletonsRestraint(bs, bl)
print(br.evaluate(False))



# Optimize the x,y,z coordinates of both particles with conjugate gradients
sf = IMP.core.RestraintsScoringFunction([br], "scoring function")
prot.set_coordinates_are_optimized(True)
o = IMP.core.ConjugateGradients(m)
o.set_scoring_function(sf)
o.optimize(50)

IMP.atom.write_pdb(prot, 'structurenew.pdb')
'''

